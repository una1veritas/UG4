\documentclass[12pt]{jreport}
\usepackage{AIthesis}
\usepackage{amsmath,amssymb}
\usepackage[dvipdfmx]{graphicx}
\usepackage{setspace}

\usepackage{algorithmic}

\newtheorem{dfn}{定義}

\newtheorem{alg}{アルゴリズム}

\setstretch{1.5}

\begin{document}
%\pagestyle{empty}
%\begin{center}
%{\Large\bf
%}
%\end{center}

\tableofcontents

\chapter{はじめに}
生体分子ネットワーク構造や, プログラムのフローチャート図など, 
データ間の関連性がある構造を表現するために, しばしばグラフ構造が用いられる.
グラフとは有限のノード集合と, ノード間を結合するエッジ集合からなるデータ構造である.
グラフ表現されたデータから人間が情報を得るには, グラフを適切に視覚化し, 
ノード間の関係やノードの情報が分かりやすく見えていることが望ましい.
しかし, グラフを分かりやすく視覚化することは難しく, 
グラフが大規模になると人間が手作業で視覚化することは困難である.
任意のグラフからグラフの二次元描画を生成する問題は, グラフ描画問題と呼ばれ, 
今日までに多くの手法が提案されている.

グラフ描画は, 人間が理解しやすいことが望ましいが, グラフごとにノードやエッジに与えられる意味は異なり, 
人によって見易さの好みが異なるため, グラフ描画に最も良いという基準を与えることは出来ない.
そのため, グラフの特徴などを考慮した適切なグラフ描画を考えていく必要がある.

特にノードの情報に着目したい場合, グラフ描画上にノード情報を表示させるために, 
ノード間に一定以上の空間を確保したいケースが考えられる.

この目的のため, 吉田英聡によって, グラフノードをパターン, グリッド状の格子点をテキストとみなした二次元点集合の近似照合によって, 
多項式時間で動作する格子状配置アルゴリズムが提案された\cite{yoshida}.
この手法により, 任意のグラフのグラフ描画において, 元々のグラフ描画の位置関係を維持しながら, 
グラフのノード間にグリッド幅以上の空白を確保したグラフ描画の生成が可能となった. 

しかし, 二次元点集合の近似照合における時間と領域の計算量は次数が高く, 
現実的なサイズのグラフ描画に対して直接適用することができなかった.
これに対し\cite{yoshida}では, kd-木分割やメッシュ状分割などでグラフを分割統治し, 大規模なグラフに実行できるようにした.
しかし, ユーザが対話的な環境で, グラフのグリッド配置アルゴリズムを利用するには, 
ユーザがストレスを感じない程度の素早い応答時間が要求され, 依然としてアルゴリズムの高速化が求められている.

そこで本研究では, 二次元点集合近似照合における格子点集合(テキスト)が, 
格子状であることに着目し, 二次元点集合近似照合を, 
グラフノード点集合(パターン)の部分集合を包含する境界矩形における, 
サイズが1ずつ増加するような真に包含関係にある境界矩形拡張列を
格子点集合上に配置する問題にみなせることを利用する.

以下では, 第2章において, 任意の点集合に対する境界矩形および境界矩形拡張列と, 
境界矩形拡張列の格子配置における編集距離の定義を行い, 
境界矩形の編集距離の再帰的定義と, 時間・空間ともに$O(n^2)$の計算量で実行可能な動的計画法(DP)による解法を紹介する.
第3章では, 境界矩形拡張列の格子配置によるグリッドグラフ描画アルゴリズムについて示した後, 
アルゴリズムの実行時間と, いくつかのグリッドグラフ描画の修正法を示し, グリッドグラフ描画の結果を示す.
第4章では結論と, 今後の課題について述べる.

\chapter{境界矩形拡張列の格子配置問題とその解法}
本章では, 二次元点集合のグリッド近似照合と, 境界矩形拡張列の格子配置について述べる.
まずはじめに, これまで行われてきた研究について紹介する.

\section{これまでの研究}
二次元点集合の近似照合の定義として, 吉田英聡は\cite{yoshida}で次のように定義した.

二次元平面上の点は正整数の組$p=(p.x, p.y)$で表す.
ここでは, 辞書式順序により二次元平面上の点に全順序をつける.
点集合$P$についてX軸, Y軸の順, およびY軸, X軸の順に辞書式順序に並べた列をそれぞれ
$P_{XY}$, $P_{YX}$とする. $(P)_R$は$P_{XY}$の最後の点の添え字, $(P)_T$は$P_{YX}$の最後の点の添え字とする.
$|P|$は$P$の要素数である.

任意の$1 \le i,j \le n$について, $P$の部分集合$P_{\le p_i}$を$P_{XY}$の最初から$p_i$までの点からなる集合, 
$P^{\le p_i}$を$P_{YX}$の最初から$p_i$までの点からなる集合とする.
$P$の部分集合$P[i,j]$は
\begin{displaymath}
P[i,j] = P[j,i] = \{ P_{\le p_i} \cap P_{\le p_j} \cap P^{\le p_i} \cap P^{\le p_j} \}
\end{displaymath}
とする.
また, $P[i,j]$から$p(P[i,j])_R$を除いた集合を$P[i,j]_-$, 
$p(P[i,j])_T$を除いた集合を$P[i,j]^-$とする.
以後, 点集合が明らかな場合は$P$を省略する.

\begin{dfn}
$n$個の点集合をそれぞれ$P,Q$とする.このとき, $1 \le i,j,k,l \le n $について$P[i,j]$と$Q[k,l]$の編集距離$d(i,j;k,l)$を
\begin{enumerate}
\item $|P[i,j]| = |Q[k,l]| = 1$ なら $d(i,j;k,l) = 0$, 
\item $|P[i,j]| \neq |Q[k,l]|$ なら $d(i,j;k,l) = \infty$, 
\item それ以外なら $d(i,j;k,l) = \\ \min
\begin{Bmatrix}
d([i,j]_-;[k,l]_-) + |p([i,j])_R - p([i,j]_-)_R - (q([k,l])_R - q([k,l]_-)_R)|, \\
d([i,j]^-;[k,l]^-) + |p([i,j])_T - p([i,j]^-)_T - (q[k,l])_T - q([k,l])^-)_T)|
\end{Bmatrix}$
\end{enumerate}
と定義する.　$|・|$は$L_1$ノルムである.
\end{dfn}

\begin{dfn}
$T$と$P$をそれぞれサイズ$m,n$の点集合とし, $\epsilon \ge 0$とする.
$T$の部分集合$T'$と$P$の編集距離が$\epsilon$以下となるとき, $P$は$T$と位置$(T')_R$において, 
$\epsilon$以下で近似照合するという.
\end{dfn}

さらに\cite{yoshida}では, $T$と$P$の近似照合を動的計画法で計算するアルゴリズムが提案された.
二次元点集合の近似照合アルゴリズムは, $O(n^2m^4)$で動作する.

テキスト$T$が格子点集合であるならば, 
任意の部分格子点集合$T[k,l]$とパターン$P[i,j]$との編集距離は, $T[k,l]$に依存せず$P[i,j]$において一意である.
この性質を利用することで, 格子点集合と二次元点集合の近似照合は, より小さいDP表で計算可能であることを次に示す.

\section{境界矩形拡張列とその格子配置における編集距離}
二次元平面上の点は正整数の組$p=(p.x, p.y)$で表す.
点集合$P$についてX軸, Y軸の順, およびY軸, X軸の順に辞書式順序に並べた列をそれぞれ$P_{XY}$, $P_{YX}$とする.
$(P)_R$は$P$に含まれる点のうち$P_{XY}$における最後の点の添え字, 
$(P)_T$は$P$に含まれる点のうち$P_{YX}$における最後の点の添え字とする.
$|P|$は$P$の要素数である.

$P$の境界矩形とは, $P$の点を全て含み各辺が座標軸に平行で最小の長方形である.

任意の$0 \le i,j \le n$について, 
$P$の部分集合$P_{\le i}$を$P_{XY}$の最初から添え字$i$までの点からなる集合, 
$P^{\le j}$を$P_{YX}$の最初から添え字$j$までの点からなる集合とする.
ただし, $P_{\le 0} = P^{\le 0} = \{\}$とする.
$P$の部分集合$P[i, j]$は
\begin{displaymath}
P[i, j] = \{ P_{\le i} \cap P^{\le j} \}
\end{displaymath}
とし, $P[i,j]$の境界矩形と$P[i,j]$を同一視する.
$P[i,j]$から$p(P[i,j])_R$を除いた点集合を$P[i,j]_-$, 
$p(P[i,j])_T$を除いた集合を$P[i,j]^-$とする.

二次元格子点集合${\rm Grid}(d)$は
$${\rm Grid}(d) = \{ (dx, dy) | x, y \in \mathbb{N} \} (d \in \mathbb{Z})$$
とする.
境界矩形$P[i,j]$が$P[i,j] \subseteq {\rm Grid}(d)$を満たすならば, $P[i,j]$は格子配置である.

サイズ$n$の点集合を$P_n$とすると, 境界矩形拡張列とは, 
$P_n[0,0]~~( |P_n[i,j]| = 0 )$から始まり$P_n[n,n]~~( |P_n[n,n]| = n )$まで, 
1点ずつサイズが増加する真に包含関係にある境界矩形の列$ P_0 \subset ... \subset P_n $である.
この時, $P_n[(P_k)_R, (P_k)_T] = P_k$とすると, 
$P_{k-1}$は$P_n[(P_k)_R, (P_k)_T]_-$または$P_n[(P_k)_R, (P_k)_T]^-$である.

境界矩形拡張列において, 
$P_k$に含まれ$P_{k-1}$に含まれない点$p$を, $P_{k-1}$から相対位置で格子配置された点を${\rm ptrans}(p, P_{k-1}) = p'$とし, 
$P_k$が{\rm ptrans}によって拡張される矩形編集距離${\rm trans_d}$を
\begin{displaymath}
{\rm trans}_d(p', P_k) = | ( P_{k-1} \cap \{ p' \} ) - P_{k} |
\end{displaymath}
とする. $|・|$は$L_1$ノルムを表す.

点集合の格子配置における編集距離を次に定義する.
\begin{dfn}
$n$個の点集合を$P$, 幅$d$の二次元格子点集合を${\rm Grid}(d)$とする.
このとき, $P[i,j]$の${\rm Grid}(d)$における編集距離$D_d(P[i, j])$を
\begin{enumerate}
\item $P[i, j] = \{\}$のとき, $D_d(\{\}) = 0$
\item それ以外のとき,  
\begin{displaymath}
D_d(P[i, j]) = \\ \min
\begin{Bmatrix}
D_d(P[i, j]_-) + {\rm trans_d}( {\rm ptrans}(p(P[i, j])_R, P[i, j]_-), P[i, j]) \\
D_d(P[i, j]^-) + {\rm trans_d}( {\rm ptrans}(p(P[i, j])_T, P[i, j]^-), P[i, j])
\end{Bmatrix}
\end{displaymath}
\end{enumerate}
と定義する.
\end{dfn}

\section{二次元点集合の格子配置とその解法}
\begin{dfn}
$P$をサイズ$n$の二次元点集合, ${\rm Grid}(d)$を幅$d$の二次元格子点集合とし, 
$\epsilon \ge 0$とする.
$P$に${\rm Grid}(d)$において編集距離が$\epsilon$以下となる境界矩形拡張列が存在するとき, 
$P$は$\epsilon$以下で格子配置されるという.
\end{dfn}

二次元点集合の格子配置の解法を以下に示す.

まず, $1 \le i, j \le n$のすべての組$(i, j)$から, 
$1 \le r \le n$において, $P[i, j]$のサイズが$r$となる組の集合のリストを作成する.
このリストの各々の要素は, サイズ$r$の部分点集合を表す添え字の組全ての集合であり, 
リストの作成は$O(n^2)$時間でできる.

次に, 各々のリストの要素に含まれるすべての組$(i, j)$から$D_d(i, j)$への写像$D$を生成する.

${\rm prev_{XY}}(i, j)$は, $P[i, j]$に含まれる$P_{XY}$における$(P)_R$を除く最後の点の添え字である.
${\rm prev_{YX}}(i, j)$も同様に, $P_{YX}$における$(P)_T$を除く最後の点の添え字である.
${\rm trans_d}(p, P)$は, $P$に含まれない点$p$を$P$から相対距離で幅$d$の格子に配置した点を$p'$としたときの, 
$P \cap \{ p' \}$と$P \cap \{ p \}$の$L_1$ノルムの差である.

写像$D$は次のアルゴリズムで計算する.
\begin{alg} ~ 
\begin{algorithmic}
\FOR{ $r$ from $1$ to $n$ }
\FOR{ each $(i, j)$ in ${\rm List}(P, r)$ }
\IF { $P_{XY}[i] = P_{YX}[j]$ }
\STATE $D_d(i, j) \gets {\rm trans_d}(P_{XY}[i], P[ {\rm prev_{XY}}(i, j), {\rm prev_{YX}}(i, j) ])$
\ELSE
\STATE $D_d(i, j) \gets \min \{ {\rm trans_d}(P_{XY}[i], P[{\rm prev_{XY}}(i, j), j]), {\rm trans_d}(P_{YX}[j], P[i, {\rm prev_{YX}}(i, j)]) \} $
\ENDIF
\ENDFOR
\ENDFOR
\end{algorithmic}
\end{alg}
写像$D$には$O(n^2)$領域必要である.
${\rm prev_{XY}}$および${\rm prev_{YX}}$を求める手続きは, 
内部でループを行うが, ループ回数は元々添え字の組のリストを生成する段階で省かれた組の数だけなので, 
このアルゴリズムは, 時間・計算ともに入力の点集合のサイズ$n$に対して, $O(n^2)$時間で動作する.

写像$D$をバックトレースすることで, 最小の編集距離で近似照合する境界矩形拡張列を求めるアルゴリズムを示す.
\begin{alg} ~
\begin{algorithmic}
\STATE $ L \gets [] $
\STATE $ i \gets n $
\STATE $ j \gets n $
\WHILE { $i > 0 ~{\rm or}~ j > 0$ }
\STATE $ i_p \gets {\rm prev_{XY}}(i, j)$
\STATE $ j_p \gets {\rm prev_{YX}}(i, j)$
\STATE push $P[i, j]$ into $L$
\IF { $P_{XY}[i] = P_{YX}[j]$ }
\STATE $ i \gets i_p$
\STATE $ j \gets j_p$
\ELSIF { $D_d(P_{XY}[i], P[i_p, j]) \le D_d(P_{YX}[j], P[i, j_p])$ }
\STATE $ i \gets i_p$
\ELSE
\STATE $ j \gets j_p$
\ENDIF
\ENDWHILE
\end{algorithmic}
\end{alg}
境界矩形を列を追加するループは, {\rm prev}の内部でのループだけスキップされるので, 
このバックトレースは$O(n)$時間で実行できる.

アルゴリズム全体を通して, $O(n^2)$時間と$O(n^2)$領域で動作する.

\chapter{実験結果}
この章では, 境界矩形拡張列によるグラフの格子配置アルゴリズムを実装し, アルゴリズムの性能を調べる実験を行う.
プログラムはC++(MinGW32-gcc-4.6.2)で実装し, Intel Core i7-3770 CPU (3.40GHz)のマシン上で実行した. 
マシンのRAMは8.00GBだが, プログラムは32bit環境向けにコンパイルしたため, 
プログラムが利用可能なメモリアドレス領域は4GB未満であった.

\section{グラフの格子配置アルゴリズム}
境界矩形拡張列の格子配置における編集距離によるグラフ格子配置アルゴリズムを次のように定義できる.
\begin{enumerate}
\item
二次元点集合$P$の格子配置における編集距離および, その境界矩形拡張列$P_0 , ... , P_n$を計算する.
\item
各々の境界矩形$P_k$において追加された点$p$を, 
$P_{k-1}$を格子配置する編集距離だけ右上方向に平行移動と, 
$P_{k-1}$から相対的に格子配置する平行移動を行った点$p'$に写像する.
\end{enumerate}
ステップ1は$O(n^2)$で動作する.
ステップ2の写像計算はステップ1で生成したDP表$D_d$を利用することで定数時間で動作し, 
計算は入力点それぞれに行うため, ステップ2全体では$O(n)$で動作する.

アルゴリズム全体を通して, グラフの格子配置は$O(n^2)$で動作する.

\section{グラフに入力される重複した点の対策}
二次元点集合に重複点が存在するとき, 現在の格子配置アルゴリズムでは冗長な形状に展開されることもある.
元々, 重複点が与えられるということは, グラフノード間に密接な関係があると考えることが人間にとって自然であるので, 
隣接関係を維持しつつグリッド状に展開する方法をアルゴリズム拡張として次を定義する.

二次元点集合$P$において, 重複点を表現するため, 各々の点$p$に対し,重複点の個数$p^m$を与える.
ここで, $p^m$に対して$L_1$ノルムが最小になる境界矩形による格子配置を与えることができる.

グラフの格子配置アルゴリズムにおいて, はじめに二次元点集合の重複点を同一視し, 各々の点の重複点の個数を記録する.

ステップ1において, 各々の境界矩形の編集距離を計算する際, 追加される点が, 
\begin{enumerate}
\item $p^m = 1$ならば, 通常の方法で編集距離を求める.
\item $p^m \ge 2$ならば, 重複点を全て格子配置するために必要な境界矩形だけ編集距離に追加する.
\end{enumerate}

ステップ2において, 写像する点が$p^m \ge 2$ならば, 
各々の重複点を, $P_{k-1}$から相対位置で格子配置されるように格子配置する.

\section{伸長したグラフの畳み込み処理}
境界矩形拡張列の計算では, 矩形が右か上のどちらか一方に拡張されるとき, 最低でもグリッド幅だけのスペースを空けることになる.
入力サイズに対してグリッド幅が疎な場合, グリッド配置は大きく展開されるため, 後処理でグラフを畳み込む処理を追加する.
グラフの畳み込み処理として, 次を定義する.

$P$がグリッド配置された点集合$P'$において, 点集合の順序関係$P_{XY}$, $P_{YX}$は保存される.
${\rm shiftLeft}および${\rm shiftBottom}は, 点列をグリッド幅だけ左および右に平行移動する関数であり, 
${\rm subList}(L, i)$は点列$L$の$i$を含む残りの部分点列とする.
次の畳み込みアルゴリズムを定義する.

\begin{alg} ~
\begin{algorithmic}
\STATE $p \gets P_{XY}[1]$
\FOR { $i$ from $P_{XY}[2]$ to $P_{XY}[n]$ }
\IF { $ p.x \le i.x - d ~~{\rm and}~~ p.y \le i.y $ }
\STATE ${\rm shiftLeft}({\rm subList}(P_{XY}, i))$
\ENDIF
\ENDFOR
\STATE $p \gets P_{YX}[1]$
\FOR { $i$ from $P_{YX}[2]$ to $P_{YX}[n]$ }
\IF { $ p.y \le i.y - d ~~{\rm and}~~ p.x \le i.x $ }
\STATE ${\rm shiftBottom}({\rm subList}(P_{YX}, i))$
\ENDIF
\ENDFOR
\end{algorithmic}
\end{alg}

\section{実験結果}
実装したプログラムに実際に点集合を入力として与え, 
プログラムの実行時間と, 点集合のグリッド配置によるグラフの伸長を計測した.
図\ref{fig:one}, 図\ref{fig:two}は, サイズ100程度の点集合に対して, アルゴリズムを実行した結果である.
実行時間は1msec以下で動作した.

次に, サイズ10000までの点集合に対して実行速度を計測するため, プログラムを実行した.
表\ref{tb:one}にその結果をまとめる.

\begin{table}[htbp]
\begin{center}
\caption{入力サイズと実行時間(標準)}
\label{tb:one}
\begin{tabular}{|c|c|} \hline
サイズ(点) & 実行時間(sec) \\ \hline \hline
1000 & 0.093 \\ \hline
2000 & 0.343 \\ \hline
3000 & 0.765 \\ \hline
4000 & 1.435 \\ \hline
5000 & 2.231 \\ \hline
6000 & 3.260 \\ \hline
7000 & 4.571 \\ \hline
8000 & 6.035 \\ \hline
9000 & bad-alloc \\ \hline
\end{tabular}
\end{center}
\end{table}

実行速度は$O(n^2)$におさまる範囲で遷移しており, 
サイズが3000程度の点集合に対しても, 十分に対話的に利用できる速度で実行された.

サイズは8000以上の入力に対しては, 実験環境ではDP表を生成するための連続した大きなヒープ領域を確保することができなかったので, 
アルゴリズムを検証することができなかった.

\begin{figure}[htbp]
\begin{center}
\includegraphics [width=100mm] {plota5.png}
\end{center}
\abovecaptionskip=-5pt
\belowcaptionskip=-10pt
\caption{Size100のグラフ}
\label{fig:one}
\end{figure}
\begin{figure}[htbp]
\begin{center}
\includegraphics [width=100mm] {plotb5.png}
\end{center}
\abovecaptionskip=-5pt
\belowcaptionskip=-10pt
\caption{矩形拡張列による格子配置}
\label{fig:two}
\end{figure}

\chapter{終わりに}
本研究では, まず点集合に対する境界矩形と境界矩形拡張列を定義し, 
境界矩形拡張列の格子配置における編集距離を再帰的に定義した.
次に, 動的計画法による境界矩形拡張列の格子配置における編集距離を, 
空間および時間ともに最悪計算量が$O(n^2)$で実行できるアルゴリズムを提案した.

そして, 境界矩形拡張列によるグラフの格子配置アルゴリズムを提案し, 
実行時間とグラフの伸長に関する実験を行った.
さらに, 重複点の展開や, グラフ展開後の畳み込み処理の追加により, 
格子配置の伸長を抑え, 元のグラフ描画における点の局所性を, 格子配置後のグラフに反映させることができた.

実装したプログラムは, サイズ3000程度まで十分に対話的に利用できるだけの速度で動作し, 
アルゴリズムが実用的な速度で利用可能な実装ができることを示した.

しかし, グラフのサイズに対して疎なグリッド幅で展開する場合, 
グリッド配置は右上方向に伸長し, グラフの全体像は線形に近づいてしまうため, 
グリッド幅は入力点のサイズに対して適切な幅を与えなければならない.

\section*{謝辞}
本研究を進めるにあたり, 細部に至るまでご指導頂いた下薗真一准教授に深く感謝いたします.
また, 日々の研究でお世話になった研究室の皆様に深く感謝の意を表します.

\renewcommand{\bibname}{参考文献}
\begin{thebibliography}{1}

\baselineskip 12pt
\bibitem{yoshida}
吉田英聡,  
二次元点集合近似照合によるグラフの格子状配置アルゴリズム, 
電子情報通信学会総合大会講演論文集 2008年 情報・システム(1),
"S-17"-"S-18",
2008-03-05

\end{thebibliography}

\end{document}
